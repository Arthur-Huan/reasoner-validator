#!/usr/bin/env python
##################################################
# Thanks to Eric Deutsch (Expander Agent) for this
# validator of ARS UUID specified TRAPI Responses
##################################################

from typing import Dict, List, Optional

import requests
from requests.exceptions import JSONDecodeError
import json
import argparse

from bmt import Toolkit
from reasoner_validator import TRAPIResponseValidator
from reasoner_validator.versioning import get_latest_version
from reasoner_validator.biolink import get_biolink_model_toolkit
from reasoner_validator.report import ValidationReporter

ARS_HOSTS = [
    'ars-prod.transltr.io',
    'ars.test.transltr.io',
    'ars.ci.transltr.io',
    'ars-dev.transltr.io',
    'ars.transltr.io'
]


def get_cli_arguments():

    # Parse command line options
    arg_parser = argparse.ArgumentParser(description='CLI validation of ARS UUID indexed TRAPI Responses.')
    arg_parser.add_argument(
        '-v', '--verbose', action='store_true',
        help='If given, show detailed information about ongoing processing, including validation results ' +
             '(Note that even if this flag is not given, non-empty validation results can still be ' +
             'selectively shown at end of script execution).'
    )
    arg_parser.add_argument(
        '--biolink_version', type=Optional[str], nargs='?', default=None,
        help='Biolink Version for validation (if omitted or None, defaults to the '
             'current default version of the Biolink Model Toolkit; ignored when "--json" flag is given).'
    )
    arg_parser.add_argument(
        '--trapi_version', type=Optional[str], nargs='?', default=None,
        help='TRAPI Version for validation (if omitted or None, defaults to the ' +
             'current default version the package; ignored when "--json" flag is given)' +
             'Note that the version may be a SemVer release, a Git branch name (e.g. master) or even'
             'a file path (with file extension .yaml) specifying or referencing the target TRAPI schema file.'
    )
    arg_parser.add_argument(
        '-q', '--query_key', type=str, nargs='?', default=None,
        help='ARS query PK identifier of a previously run query. Ignored when an --endpoint is given.'
    )
    arg_parser.add_argument(
        '-e', '--endpoint', type=str, nargs='?', default=None,
        help='Target TRAPI service endpoint to be directly used for query. Overrides the --query_key CLI argument.'
    )
    arg_parser.add_argument(
        '-l', '--local_request', type=Optional[str], nargs='?', default=None,
        help='Local JSON input text file source of the TRAPI Request. Mandatory when --endpoint CLI argument is given.'
    )
    arg_parser.add_argument(
        '-j', '--json', action='store_true',
        help='If given, dump validation messages in JSON format '
             '(default: dump messages in human readable format).'
    )
    arg_parser.add_argument(
        '--title', type=Optional[str], nargs='?', default=None,
        help='User provided string for human readable report output title (title suppressed if None; ' +
             'if a blank string is given then title is autogenerated; ignored when "--json" flag is given).'
    )
    arg_parser.add_argument(
        '-n', '--number_of_identifiers',
        metavar='N', type=int, nargs='?', default=0,
        help='Maximum integer N number of message indexing identifiers to report per validation code; ' +
             'set to zero if all identifiers are to be reported (ignored when "--json" flag is given).'
    )
    arg_parser.add_argument(
        '-m', '--number_of_messages',
        metavar='N', type=int, nargs='?', default=0,
        help='Maximum integer N number of messages to report per indexing identifier; set to zero if all messages ' +
             'are to be reported (default: 0, display all identifiers; ignored when "--json" flag is given).'
    )
    arg_parser.add_argument(
        '-c', '--compact_format', action='store_true',
        help='If given, compress human readable text output by suppressing blank lines '
             '(default: False; ignored when "--json" flag is given).'
    )

    return arg_parser.parse_args()


def direct_trapi_request(endpoint: str, trapi_request, verbose: bool) -> Optional[Dict]:
    return dict()


def retrieve_ars_result(query_key: str, verbose: bool) -> Optional[Dict]:
    if verbose:
        print(f"Trying to retrieve ARS Response UUID '{query_key}'...")
        
    response_content: Optional = None
    status_code: int = 404
    
    for ars_host in ARS_HOSTS:
        if verbose:
            print(f"\n...from {ars_host}", end=None)
        try:
            response_content = requests.get(
                f"https://{ars_host}/ars/api/messages/"+query_key,
                headers={'accept': 'application/json'}
            )
            if response_content:
                status_code = response_content.status_code
                if status_code == 200:
                    print(f"...Result returned from '{ars_host}'!")
                    break
            else:
                status_code = 404

        except Exception as e:
            print(f"Remote host {ars_host} unavailable: Connection attempt to {ars_host} triggered an exception: {e}")
            response_content = None
            status_code = 404
            continue

    if status_code != 200:
        print(f"Unsuccessful HTTP status code '{status_code}' reported for ARS PK '{query_key}'?")
        return None

    # Unpack the response content into a dict
    try:
        response_dict = response_content.json()
    except JSONDecodeError:
        print("Cannot decode ARS UUID "+query_key+" to a Translator Response")
        return None

    if 'fields' in response_dict:
        if 'actor' in response_dict['fields'] and str(response_dict['fields']['actor']) == '9':
            print("The supplied response id is a collection id. Please supply the UUID for a response")
        elif 'data' in response_dict['fields']:
            print(f"Validating ARS PK '{query_key}' TRAPI Response result...")
            return response_dict['fields']['data']
        else:
            print("ARS response dictionary is missing 'fields.data'?")
    else:
        print("ARS response dictionary is missing 'fields'?")

    return None


def validation_report(validator: TRAPIResponseValidator, args):

    def prompt_user(msg: str):
        text = input(f"{msg} (Type 'Y' or 'Yes' to show): ")
        text = text.upper()
        if text == "YES" or text == "Y":
            return True
        else:
            return False

    show_messages: bool = False
    if validator.has_errors() or validator.has_warnings():
        show_messages = prompt_user("Validation errors and/or warnings were reported")
    elif validator.has_information():
        show_messages = prompt_user("No validation errors or warnings, but some information was reported")

    if show_messages or args.verbose:
        if args.json:
            print(json.dumps(validator.get_messages(), sort_keys=True, indent=2))
        else:
            validator.dump(
                title=args.title,
                id_rows=args.number_of_identifiers,
                msg_rows=args.number_of_messages,
                compact_format=args.compact_format
            )


def main():

    args = get_cli_arguments()

    # Query and print some rows from the reference tables
    if args.endpoint:
        if args.local_request:
            trapi_response = direct_trapi_request(args.endpoint, args.request, args.verbose)
        else:
            print("Need to specific a --local_request JSON input text file (path) argument for your TRAPI endpoint!")
            return
    elif args.query_key:
        trapi_response = retrieve_ars_result(args.query_key, args.verbose)
    else:
        print("Need to specify either an --endpoint/--local_request or a --query_key input argument to proceed!")
        return

    if not trapi_response:
        print("Need to specify either an --endpoint/--local_request or a --query_key input argument to proceed!")
        return

    # Explicitly resolve the TRAPI release to be used
    inferred_trapi_version: str = args.trapi_version \
        if args.trapi_version else ValidationReporter.DEFAULT_TRAPI_VERSION
    resolved_trapi_version = get_latest_version(inferred_trapi_version)

    # Explicitly resolve the Biolink Model version to be used
    bmt: Toolkit = get_biolink_model_toolkit(biolink_version=args.biolink_version)
    resolved_biolink_version: str = bmt.get_model_version()
    if args.verbose:
        print(
            f"Validating against TRAPI '{resolved_trapi_version}' and "
            f"Biolink Model version '{resolved_biolink_version}'"
        )

    # Perform a validation on it
    validator = TRAPIResponseValidator(
        trapi_version=resolved_trapi_version,
        biolink_version=resolved_biolink_version
    )

    # the heavy lifting ...
    validator.check_compliance_of_trapi_response(trapi_response)

    validation_report(validator, args)


if __name__ == "__main__":
    main()
